priority -50

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python3
# -*- coding: utf8 -*-
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:
	${1:${VISUAL:main()}}
endsnippet

snippet with "with" b
with ${1:expr}`!p snip.rv = " as " if t[2] else ""`${2:var}:
	${3:${VISUAL:pass}}
${0}
endsnippet

snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

snippet forl "for each line" b
for line in ifs:
	lst_fields = line.rstrip().split('${1:\t}')
	${2}
endsnippet

##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2
SPHINX  = 0x3
GOOGLE  = 0x4
NUMPY   = 0x5
JEDI    = 0x6
BAIDU   = 0x7

SINGLE_QUOTES = "'"
DOUBLE_QUOTES = '"'


class Arg(object):
	def __init__(self, arg):
		self.arg = arg
		self.name = arg.split('=')[0].strip()
		self.value_str = arg.split('=')[1].strip() if self.is_kwarg() else None

	def __str__(self):
		return self.name

	def __unicode__(self):
		return self.name

	def is_kwarg(self):
		return '=' in self.arg

	def value(self):
		if self.value_str is None:
			raise ValueError('no default value is given')
		return self.value_str


def get_args(arglist):
	args = [Arg(arg) for arg in arglist.split(',') if arg]
	args = [arg for arg in args if arg.name != 'self']

	return args


def get_quoting_style(snip):
	style = snip.opt("g:ultisnips_python_quoting_style", "double")
	if style == 'single':
		return SINGLE_QUOTES
	return DOUBLE_QUOTES

def triple_quotes(snip):
	style = snip.opt("g:ultisnips_python_triple_quoting_style")
	if not style:
		return get_quoting_style(snip) * 3
	return (SINGLE_QUOTES if style == 'single' else DOUBLE_QUOTES) * 3

def triple_quotes_handle_trailing(snip, quoting_style):
	"""
	Generate triple quoted strings and handle any trailing quote char,
	which might be there from some autoclose/autopair plugin,
	i.e. when expanding ``"|"``.
	"""
	if not snip.c:
		# Do this only once, otherwise the following error would happen:
		# RuntimeError: The snippets content did not converge: â€¦
		_, col = vim.current.window.cursor
		line = vim.current.line

		# Handle already existing quote chars after the trigger.
		_ret = quoting_style * 3
		while True:
			try:
				nextc = line[col]
			except IndexError:
				break
			if nextc == quoting_style and len(_ret):
				_ret = _ret[1:]
				col = col+1
			else:
				break
		snip.rv = _ret
	else:
		snip.rv = snip.c

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")

	if    style == "baidu": return BAIDU
	elif  style == "doxygen": return DOXYGEN
	elif  style == "sphinx": return SPHINX
	elif  style == "google": return GOOGLE
	elif  style == "numpy": return NUMPY
	elif  style == "jedi": return JEDI
	else: return NORMAL


def format_arg(arg, style):
	dft_comment = 'default is ' + arg.value() if arg.is_kwarg() else 'NULL'
	if style in (BAIDU, GOOGLE):
		return "%s (TYPE): %s" % (arg, dft_comment)
	elif style == DOXYGEN:
		return "@param %s %s" % (arg, dft_comment)
	elif style == SPHINX:
		return ":param %s: %s" % (arg, dft_comment)
	elif style == NORMAL:
		return ":%s: %s" % (arg, dft_comment)
	elif style == JEDI:
		return ":type %s: %s" % (arg, dft_comment)
	elif style == NUMPY:
		return "%s : %s" % (arg, dft_comment)


def format_return(style, desc='TODO'):
	if style == DOXYGEN:
		return "@return: %s" % (desc)
	elif style in (BAIDU, GOOGLE):
		return "Returns: %s" % (desc)
	elif style in (NORMAL, SPHINX, JEDI):
		return ":returns: %s" % (desc)


def format_raise(style):
	if style == DOXYGEN:
		return "@raise: NULL"
	elif style in (BAIDU, GOOGLE):
		return "Raises: NULL"
	elif style in (NORMAL, SPHINX, JEDI):
		return ":raises: NULL"


def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' {0}'.format(triple_quotes(snip))
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	if style == BAIDU:
		write_baidu_docstring_args(args, snip)
	elif style == GOOGLE:
		write_google_docstring_args(args, snip)
	elif style == NUMPY:
		write_numpy_docstring_args(args, snip)
	else:
		for arg in args:
			snip += format_arg(arg, style)


def write_baidu_docstring_args(args, snip):
	snip += "Args:"
	snip.shift()
	for arg in args:
		snip += format_arg(arg, GOOGLE)
	snip.unshift()
	snip.rv += '\n' + snip.mkline('', indent='')


def write_google_docstring_args(args, snip):
	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		snip += "Args:"
		snip.shift()
		for arg in args:
			snip += format_arg(arg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')

	if kwargs:
		snip += "Kwargs:"
		snip.shift()
		for kwarg in kwargs:
			snip += format_arg(kwarg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')


def write_numpy_docstring_args(args, snip):
	if args:
		snip += "Parameters"
		snip += "----------"

	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		for arg in args:
			snip += format_arg(arg, NUMPY)
	if kwargs:
		for kwarg in kwargs:
			snip += format_arg(kwarg, NUMPY) + ', optional'
	snip.rv += '\n' + snip.mkline('', indent='')


def write_init_body(args, name, parents, snip):
	name = name.strip()
	parents = [p.strip() for p in parents.split(",")]

	if len(parents) > 0:
		snip += "super(%s, self).__init__()" % (name.strip())
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in args:
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	args = ['"_%s"' % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)


def write_function_docstring(t, snip):
	"""
	Writes a function docstring with the current style.

	:param t: The values of the placeholders
	:param snip: UltiSnips.TextObjects.SnippetUtil object instance
	"""
	snip.rv = ""
	snip >> 1

	args = get_args(t[2])
	if args:
		write_docstring_args(args, snip)

	style = get_style(snip)

	if style == NUMPY:
		snip += 'Returns'
		snip += '-------'
		snip += 'NULL'
	else:
		snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')

	if style == NUMPY:
		snip += 'Raises'
		snip += '-------'
		snip += 'NULL'
	else:
		snip += format_raise(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

def get_dir_and_file_name(snip):
	return os.getcwd().split('/')[-1] + '.' + snip.basename

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:init of class}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '{0}'.format(triple_quotes(snip))

write_init_body(args, t[1], t[2], snip)
`
		$0
endsnippet

snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`
`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:init of class}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

write_init_body(args, t[1], t[2], snip)
`
		$0
endsnippet


snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defc "class method with docstrings" b
@classmethod
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'cls' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defs "static method with docstrings" b
@staticmethod
def ${1:function}(${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

# doesn't expand when there is a word in front

snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet fr "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet rprop "Read Only Property" b
@property
def ${1:name}(self):
	"""read property of $1"""
	return self.${2:_$1}$0
endsnippet

snippet prop "Read write property" b
@property
def ${1:name}(self):
	"""read property of $1"""
	return self.${2:_$1}

@$1.setter
def $1(self, value):
	"""write property of $1"""
	self.$2 = value$0
endsnippet

## snippet prop "Read write property" b
## def ${1:name}():
## 	`!p snip.rv = triple_quotes(snip) if t[2] else ''
## `${2:getter and setter for $1.}`!p
## if t[2]:
## 	snip >> 1
## 
## 	style = get_style(snip)
## 	snip.rv += '\n' + snip.mkline('', indent='')
## 	snip += format_return(style, 'dict   <func_name, func_ins>')
## 	snip.rv += '\n' + snip.mkline('', indent='')
## 	snip += triple_quotes(snip)
## else:
## 	snip.rv = ''`
## 	def fget(self):
## 		"""getter of $1"""
## 		return self._$1
## 
## 	def fset(self, value):
## 		"""setter of $1"""
## 		self._$1 = value
## 	return locals()
## 
## $1 = property(doc=$1.__doc__, **$1())
## $0
## endsnippet


####################
# If / Else / Elif #
####################
snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
endsnippet

snippet trye "Try / Except / Else" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet tryf "Try / Except / Finally" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet tryef "Try / Except / Else / Finally" b
try:
	${1:${VISUAL:pass}}
except${2: ${3:Exception} as ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


######################
# Assertions & Tests #
######################

snippet ae "Assert equal" b
self.assertEqual(${1:${VISUAL:first}},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${1:${VISUAL:expression}})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:${VISUAL:expression}})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:${VISUAL:first}},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:${VISUAL:func}}${3/.+/, /}${3:arguments})
endsnippet

snippet an "Assert is None" b
self.assertIsNone(${1:${VISUAL:expression}})
endsnippet

snippet ann "Assert is not None" b
self.assertIsNotNone(${1:${VISUAL:expression}})
endsnippet

snippet ut "pyunit testcase" b
class Test${1:Class}(unittest.TestCase):

	`!p snip.rv = triple_quotes(snip)`${2:Test case docstring.}`!p snip.rv = triple_quotes(snip)`

	def setUp(self):
		${3:pass}

	def tearDown(self):
		${4:pass}

	def test_${5:name}(self):
		"""test function of $5"""
		${6:${VISUAL:pass}}
endsnippet

snippet deft
def test_${1:function_name}(self):
	"""test function of $1"""
	${2:pass}
endsnippet

snippet " "triple quoted string (double quotes)" b
"""
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, '"')`
endsnippet

snippet ' "triple quoted string (single quotes)" b
'''
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, "'")`
endsnippet

snippet doc "doc block (triple quotes)"
`!p snip.rv = triple_quotes(snip)`
${1:${VISUAL:doc}}
`!p snip.rv = triple_quotes(snip)`
endsnippet

snippet pmdoc "pocoo style module doc string" b
# -*- coding: utf-8 -*-
"""
	`!p snip.rv = get_dir_and_file_name(snip)`
	`!p snip.rv = '~' * len(get_dir_and_file_name(snip))`

	${1:DESCRIPTION}

	:copyright: (c) `date +%Y` by ${2:YOUR_NAME}.
	:license: ${3:LICENSE_NAME}, see LICENSE for more details.
"""
$0
endsnippet

################################################################################
#
#                       user defined snippets
#
################################################################################

global !p
def basic_log(logfile=None, filemode='a'):
	if logfile is None:
		filename_pram = "filename=None"
	else:
		filename_pram = "filename='%s'" % (logfile)

	return "logging.basicConfig(level=logging.DEBUG,\n" + \
            "        format='%(levelname)s: %(asctime)s %(filename)s'\n" + \
            "        ' [%(funcName)s:%(lineno)d][%(process)d] %(message)s',\n" + \
            "        datefmt='%m-%d %H:%M:%S',\n" + \
            "        %s,\n" % (filename_pram) + \
            "        filemode='%s')" % (filemode)



endglobal

snippet log
`!p snip.rv = basic_log()`
endsnippet


snippet args "" b
from argparse import ArgumentParser
arg_parser = ArgumentParser(description="${1:description}")
arg_parser.add_argument("input", nargs="?", help="input file path")
arg_parser.add_argument("-o", "--output", dest="output", help="output file path")
args = arg_parser.parse_args()
${2}
endsnippet


snippet env
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${1:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging

`!p snip.rv = basic_log()`

if __name__ == "__main__":
	from argparse import ArgumentParser
	try:
		arg_parser = ArgumentParser(description="$1")
		arg_parser.add_argument("input", nargs="?", help="input file path")
		arg_parser.add_argument("-o", "--output", dest="output", help="output file path")
		args = arg_parser.parse_args()

		${2}
	except Exception as e:
		traceback.print_exc()
		logging.critical(traceback.format_exc())
		exit(-1)

endsnippet


snippet lib
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${1:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging

${2}

if __name__ == "__main__":
	"""run some simple test cases"""
	pass

endsnippet


snippet ienv "env for __init__.py file" b
# -*- coding:utf8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${1:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

${2}
endsnippet


snippet blib "env for bigflow code" b
#!/usr/bin/env ${1:pyrun}
# -*- coding:utf8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${2:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging
${3}

endsnippet


snippet benv "env for bigflow code" b
#!/usr/bin/env ${1:pyrun}
# -*- coding:utf8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${2:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging

from bigflow import base
from bigflow import transforms
from bigflow import input
from bigflow import output

from bigflow_utils import BigflowUtils
from autoopt_basic import common_arg_parser
from autoopt_basic import parse_args
from autoopt_basic import hdfs_workroot

def create_arg_parser(argv):
	"""create_arg_parser
	
	Args: argv      list of args

	Returns:
		an arp-parser 

	Raises: error of arg_parser.parse_args()
	"""
	arg_parser = common_arg_parser(description="$2")
	#arg_parser.add_argument('...')
	args = parse_args(arg_parser, argv)
	return args


def create_pipeline(args):
	"""create_pipeline
	
	Args:
		args    args result of argparser

	Returns:
		a pipeline of bigflow 

	Raises: None

	Exit:
		-1 		if get run mode failed
	"""
	pipeline_params = {}
	if args.is_local:
		pipeline_params['pipeline_type'] = "LOCAL"
	elif args.is_hadoop:
		pipeline_params['pipeline_type'] = "HADOOP"
		pipeline_params['default_concurrency'] = 97
		pipeline_params['hadoop_job_conf'] = {
				"mapred.job.map.capacity": "200",
				"mapred.job.reduce.capacity": "100",
				"mapred.job.priority" : "NORMAL",
				"abaci.dag.datasize.per.reduce": str(1000 * 1000 * 10),
				"mapred.job.name": "nlp_zhangao_stat_query",
		}

		pipeline_params['tmp_data_path'] = 'afs:///user/nlp/ip/zhangao/bigflow_tmp_path'
	else:
		logging.critical("bigflow run mode setting error")
		exit(-1)

	# create a pipeline
	pipeline = BigflowUtils.create_pipeline(**pipeline_params)
	return pipeline

if __name__ == "__main__":
	try:
		args = create_arg_parser(sys.argv[1:])
		pipeline = create_pipeline(args)
		BigflowUtils.add_lib("bigflow_utils", pipeline)
		BigflowUtils.add_lib("autoopt_basic", pipeline)

		pc_input = pipeline.read(input.TextFile(args.inpath))\
				   .map(lambda x: x.rstrip().split('\t'))
		${4}

		pipeline.write(pc_output, output.TextFile(args.outpath))

		BigflowUtils.autorun()
	except Exception as e:
		logging.critical(traceback.format_exc())
		exit(-1)
	
endsnippet

snippet aenv "init of python file" b
#!/usr/bin/env python
# -*- coding:utf-8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""${1:description}

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging

from autoopt_basic import common_arg_parser
from autoopt_basic import parse_args

`!p snip.rv = basic_log()`

def create_arg_parser(argv):
	"""create_arg_parser
	
	Args: argv      list of args

	Returns:
		an arp-parser 

	Raises: error of arg_parser.parse_args()
	"""
	arg_parser = common_arg_parser(description="$1")
	#arg_parser.add_argument('-x')
	args = parse_args(arg_parser, argv)
	return args


if __name__ == "__main__":
	try:
		args = create_arg_parser(sys.argv[1:])
		${2}
	except Exception as e:
		logging.critical(traceback.format_exc())
		exit(-1)

endsnippet

snippet utenv
#!/usr/bin/env ${1:python3}
# -*- coding:utf8 -*-
##########################################################
# Copyright (c) `!v strftime("%Y")` Baidu.com, Inc. All Rights Reserved #
##########################################################

"""unittest of $3.$4

Filname: `!v expand("%:t")`
Authors: ZhangAo(@baidu.com)
Date: `date +"%Y-%m-%d %H:%M:%S"`
"""

import sys
import os
import traceback
import logging
import unittest

from ${3:module} import ${4:file_to_be_tested}

${5}

if __name__ == "__main__":
	os.mkdir('log') if not os.path.isdir('log') else None
	`!p snip.rv = basic_log('log/%s.log' % (fn.rsplit('.', 1)[0]), 'w')`

	unittest.main()
endsnippet

snippet pipeline
def create_pipeline(args):
	"""create_pipeline
	
	Args:
		args    args result of argparser

	Returns:
		a pipeline of bigflow 

	Raises: None

	Exit:
		-1 		if get run mode failed
	"""
	pipeline_params = {}
	if args.is_local:
		pipeline_params['pipeline_type'] = "LOCAL"
	elif args.is_hadoop:
		pipeline_params['pipeline_type'] = "HADOOP"
		pipeline_params['tmp_data_path'] = hdfs_workroot() + '/tmp'
	else:
		logging.critical("bigflow run mode setting error")
		exit(-1)

	# create a pipeline
	pipeline = BigflowUtils.create_pipeline(**pipeline_params)
	return pipeline

endsnippet

snippet fs
ifs = None
ofs = None
if args.${1:input} is None:
	logging.info("<input> is None. using stdin instead.")
	ifs = sys.stdin
elif os.path.isfile(args.$1):
	ifs = open(args.$1, 'r')
else:
	logging.critical("input file does not exist: [%s]" % args.$1)
	exit(-1)
if args.${2:output} is None:
	logging.info("<output> is None. using stdout instead.")
	ofs = sys.stdout
else:
	ofs = open(args.$2, 'w')

${3}

ifs.close()
ofs.close()
endsnippet

snippet stderr
sys.stderr.write("${1}\n")${2}
endsnippet

snippet group "" b
group = grouper.Grouper(ifs)
while group.has_next():
	key = group.get_key()
	${1}
	while group.key_same():
		value = group.next_value()
		${2}
endsnippet

snippet imnt
from collections import namedtuple
endsnippet

snippet imdd
from collections import defaultdict
endsnippet



# vim:ft=snippets:
